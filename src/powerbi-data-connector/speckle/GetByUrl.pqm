(url as text, optional ExpandProperties as logical) as table =>
    let
        // set default value for ExpandProperties
        shouldExpandProperties = if ExpandProperties = null then false else ExpandProperties,

        // import required functions
        GetStructuredData = Extension.LoadFunction("GetStructuredData.pqm"),
        SendToServer = Extension.LoadFunction("SendToServer.pqm"),
        GetModel = Extension.LoadFunction("GetModel.pqm"),
        Parser = Extension.LoadFunction("Parser.pqm"),
        CheckPermissions = Extension.LoadFunction("CheckPermissions.pqm"),
        ExchangeToken = Extension.LoadFunction("ExchangeToken.pqm"),
        EncodeUserInfo = Extension.LoadFunction("EncodeUserInfo.pqm"),
        GetUser = Extension.LoadFunction("GetUser.pqm"),
        GetVersion = Extension.LoadFunction("GetVersion.pqm"),
        GetWorkspace = Extension.LoadFunction("GetWorkspace.pqm"),

        // the logic for importing functions from other files
        Extension.LoadFunction = (fileName as text) =>
            let
                binary = Extension.Contents(fileName),
                asText = Text.FromBinary(binary)
            in
                try
                    Expression.Evaluate(asText, #shared)
                catch (e) =>
                    error
                        [
                            Reason = "Extension.LoadFunction Failure",
                            Message.Format = "Loading '#{0}' failed - '#{1}': '#{2}'",
                            Message.Parameters = {fileName, e[Reason], e[Message]},
                            Detail = [File = fileName, Error = e]
                        ],

        // parse the URL to determine if it's a federated model
        parsedUrl = Parser(url),

        // check if user has permission to load the model
        permissionCheck = CheckPermissions(url),

        // assert that permission check returned a valid result
        permissionAssert = if not Record.HasFields(permissionCheck, {"authorized", "code", "message"}) then
            error "Invalid permission check result"
        else
            null,

        // if not authorized, throw an error with the message from the server
        authCheck = if not permissionCheck[authorized] then
            error Text.Format(
                "Permission denied: #{0} (Error code: #{1})",
                {permissionCheck[message], permissionCheck[code]}
            )
        else
            null,

        // get user info, connector version, and workspace info for encoding
        userInfo = GetUser(url),
        powerfulToken = userInfo[Token],
        userEmail = userInfo[UserEmail],
        connectorVersion = GetVersion(),
        workspaceInfo = GetWorkspace(url),

        // exchange powerful token for weak token with limited scopes
        tokenExchangeResult = ExchangeToken(
            powerfulToken,
            {"profile:read", "streams:read", "users:read"},
            parsedUrl[projectId],
            parsedUrl[baseUrl]
        ),

        // throw error if token exchange failed - do NOT use powerful token as fallback
        tokenToUse = if tokenExchangeResult[Success] then
            tokenExchangeResult[Token]
        else
            error [
                Reason = "TokenExchangeFailed",
                Message.Format = "Failed to exchange token for limited scope token: #{0}",
                Message.Parameters = {tokenExchangeResult[ErrorMessage]},
                Detail = [
                    ErrorMessage = tokenExchangeResult[ErrorMessage],
                    ProjectId = parsedUrl[projectId],
                    ServerUrl = parsedUrl[baseUrl]
                ]
            ],
            
        // only proceed if user has permisson to load
        results = if permissionCheck[authorized] then
            if parsedUrl[isFederated] = true then
                // process each model in the federation
                let
                    modelsData = List.Transform(
                        parsedUrl[federatedModels],
                        each ProcessSingleModel(
                            parsedUrl[baseUrl],
                            parsedUrl[projectId],
                            [modelId],
                            [versionId]
                        )
                    ),

                    // extract all data tables
                    allTables = List.Transform(modelsData, each [Data]),

                    // extract all encoded userInfo strings
                    allEncodedUserInfos = List.Transform(modelsData, each [EncodedUserInfo]),

                    // combine all encoded userInfo strings with delimiter |||
                    // (delimiter chosen to avoid conflicts with base64 characters)
                    combinedEncodedUserInfos = Text.Combine(allEncodedUserInfos, "|||"),

                    // combine all data tables
                    combinedData = Table.Combine(allTables),

                    // replace the "Model Info" column with the combined encoded strings
                    transformedData = Table.TransformColumns(
                        combinedData,
                        {"Model Info", each combinedEncodedUserInfos}
                    ),

                    // expand properties column if requested and if it exists
                    finalData = if shouldExpandProperties and Table.HasColumns(transformedData, {"properties"}) then
                        try
                            Speckle.Utils.ExpandRecord(transformedData, "properties")
                        otherwise
                            transformedData  // fallback to original data if expansion fails
                    else
                        transformedData
                in
                    finalData
            else
                // use existing functionality for single models
                let
                    // get model info
                    modelInfo = GetModel(url),
                    modelName = modelInfo[modelName],
                    rootObjectId = modelInfo[rootObjectId],
                    sourceApplication = modelInfo[sourceApplication],
                    versionId = modelInfo[versionId],

                    // get structured data
                    structuredData = GetStructuredData(url),

                    // build userInfoData record for this model
                    userInfoData = [
                        rootObjectId = rootObjectId,
                        server = parsedUrl[baseUrl],
                        email = userEmail,
                        projectId = parsedUrl[projectId],
                        token = tokenToUse,
                        workspaceId = workspaceInfo[workspaceId],
                        workspaceName = workspaceInfo[workspaceName],
                        workspaceLogo = workspaceInfo[workspaceLogo],
                        version = connectorVersion,
                        sourceApplication = sourceApplication,
                        canHideBranding = workspaceInfo[canHideBranding],
                        versionId = versionId,
                        url = url
                    ],

                    // encode userInfoData as base64 JSON string
                    encodedUserInfo = EncodeUserInfo(userInfoData),

                    // replace "Model Info" column with encoded string
                    transformedData = Table.TransformColumns(
                        structuredData,
                        {"Model Info", each encodedUserInfo}
                    ),

                    // expand properties column if requested and if it exists
                    result = if shouldExpandProperties and Table.HasColumns(transformedData, {"properties"}) then
                        try
                            Speckle.Utils.ExpandRecord(transformedData, "properties")
                        otherwise
                            transformedData  // fallback to original data if expansion fails
                    else
                        transformedData
                in
                    result
        else
            error Text.Format(
                "Permission denied: #{0} (Error code: #{1})", 
                {permissionCheck[message], permissionCheck[code]}
            ),
                
        // function to process a single model and get its data
        ProcessSingleModel = (baseUrl, projectId, modelId, versionId) =>
            let
                // construct a standard URL for the model
                singleModelUrl = Text.Combine({
                    baseUrl,
                    "/projects/",
                    projectId,
                    "/models/",
                    modelId,
                    if versionId <> null then Text.Combine({"@", versionId}) else ""
                }),

                // get model info
                modelInfo = GetModel(singleModelUrl),
                rootObjectId = modelInfo[rootObjectId],
                modelName = modelInfo[modelName],
                sourceApplication = modelInfo[sourceApplication],

                // get structured data
                structuredData = GetStructuredData(singleModelUrl),

                // build userInfoData record for this model
                userInfoData = [
                    rootObjectId = rootObjectId,
                    server = baseUrl,
                    email = userEmail,
                    projectId = projectId,
                    token = tokenToUse,
                    workspaceId = workspaceInfo[workspaceId],
                    workspaceName = workspaceInfo[workspaceName],
                    workspaceLogo = workspaceInfo[workspaceLogo],
                    version = connectorVersion,
                    sourceApplication = sourceApplication,
                    canHideBranding = workspaceInfo[canHideBranding],
                    versionId = if versionId <> null then versionId else modelInfo[versionId],
                    url = singleModelUrl
                ],

                // encode userInfoData as base64 JSON string
                encodedUserInfo = EncodeUserInfo(userInfoData),

                // add the model name as context - with version id if exists
                result = Table.AddColumn(
                    structuredData,
                    "Source Model",
                    each if versionId <> null then
                        Text.Combine({modelName, "-", versionId})
                    else
                        modelName,
                    type text
                )
            in
                [
                    Data = result,
                    RootObjectId = rootObjectId,
                    EncodedUserInfo = encodedUserInfo
                ]
    in
        results
