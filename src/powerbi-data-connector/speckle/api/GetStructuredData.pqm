// function for getting structured object data
(url as text) as table =>
    let
        // import the required functions
        GetModel = Extension.LoadFunction("GetModel.pqm"),
        SendToServer = Extension.LoadFunction("SendToServer.pqm"),
       
        // the logic for importing functions from other files
        Extension.LoadFunction = (fileName as text) =>
            let
                binary = Extension.Contents(fileName),
                asText = Text.FromBinary(binary)
            in
                try
                    Expression.Evaluate(asText, #shared)
                catch (e) =>
                    error
                        [
                            Reason = "Extension.LoadFunction Failure",
                            Message.Format = "Loading '#{0}' failed - '#{1}': '#{2}'",
                            Message.Parameters = {fileName, e[Reason], e[Message]},
                            Detail = [File = fileName, Error = e]
                        ],
       
        // get model info and server data
        modelInfo = GetModel(url),
        rootId = modelInfo[rootObjectId],
       
        // Get the data from SendToServer - this is already a response from the service
        JsonResponse = SendToServer(url),
       
        // convert list to table with all columns expanded
        TableFromList = Table.FromList(
            JsonResponse,
            Splitter.SplitByNothing(),
            null,
            null,
            ExtraValues.Error
        ),
        // fields to remove from data record
        FieldsToRemove = {"__closure", "totalChildrenCount", "renderMaterialProxies"},
        
        // create basic table with cleaned data records (no properties column yet)
        BasicTable = Table.FromRecords(
            List.Transform(
                TableFromList[Column1],
                each let
                    record = _,
                    fieldsToRemoveForThisRecord = List.Select(
                        FieldsToRemove,
                        each Record.HasFields(record, {_})
                    ),
                    cleanedRecord = Record.RemoveFields(record, fieldsToRemoveForThisRecord)
                in
                    [
                        #"Object IDs" = record[id], // Object IDs
                        #"Speckle Type" = record[speckle_type], // Speckle Type
                        #"Version Object ID" = rootId,
                        #"Model Info" = rootId,
                        #"Application ID" = Record.FieldOrDefault(cleanedRecord, "applicationId", null), // Application ID
                        data = cleanedRecord // Data
                    ]
            )
        ),
       
        // function to check if a row should be excluded based on speckle type
        ShouldExcludeRow = (row as record) as logical =>
            let
                speckleType = Record.FieldOrDefault(row[data], "speckle_type", "")
            in
                speckleType = "Speckle.Core.Models.DataChunk" or 
                Text.Contains(speckleType, "Objects.Other.RawEncoding"),
       
        // Filtering logic here 
        // If model data contains any DataObject -> fetch only data objects (excluding unwanted types)
        // If there are no data objects in the data -> fetch everything but exclude DataChunks and RawEncoding
        // Check if model contains any DataObject
        HasDataObjects = Table.RowCount(
            Table.SelectRows(
                BasicTable, 
                each Text.Contains(Record.FieldOrDefault([data], "speckle_type", ""), "DataObject") 
                     and not ShouldExcludeRow(_)
            )
        ) > 0,

        // load the Objects.Properties function only if we have DataObjects
        ObjectsProperties = if HasDataObjects then Extension.LoadFunction("Objects.Properties.pqm") else null,
        
        // Add properties column only if model has DataObjects
        FinalTable = if HasDataObjects then
            Table.AddColumn(
                BasicTable,
                "properties",
                each let
                    dataRecord = [data],
                    isDataObject = Text.Contains(Record.FieldOrDefault(dataRecord, "speckle_type", ""), "DataObject"),
                    hasProperties = Record.HasFields(dataRecord, {"properties"}),
                    extractedProperties = if hasProperties and isDataObject then 
                        try ObjectsProperties(dataRecord) otherwise []
                    else 
                        []
                in
                    if Record.FieldCount(extractedProperties) > 0 then extractedProperties else null
            )
        else
            BasicTable,

        // Apply the same filtering logic as before
        FilteredTable = if HasDataObjects then
            Table.SelectRows(
                FinalTable, 
                each Text.Contains(Record.FieldOrDefault([data], "speckle_type", ""), "DataObject") 
                     and not ShouldExcludeRow(_)
            )
        else
            Table.SelectRows(FinalTable, each not ShouldExcludeRow(_))
    in
        FilteredTable