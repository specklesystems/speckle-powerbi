(url as text) as list =>
    let
        GetModel = Extension.LoadFunction("GetModel.pqm"),
        Parser = Extension.LoadFunction("Parser.pqm"),
        GetUser = Extension.LoadFunction("GetUser.pqm"),
        ExchangeToken = Extension.LoadFunction("ExchangeToken.pqm"),

        // helper function to load .pqm modules dynamically
        Extension.LoadFunction = (fileName as text) =>
            let
                binary = Extension.Contents(fileName),
                asText = Text.FromBinary(binary)
            in
                try
                    Expression.Evaluate(asText, #shared)
                catch (e) =>
                    error
                        [
                            Reason = "Extension.LoadFunction Failure",
                            Message.Format = "Loading '#{0}' failed - '#{1}': '#{2}'",
                            Message.Parameters = {fileName, e[Reason], e[Message]},
                            Detail = [File = fileName, Error = e]
                        ],

        modelInfo = GetModel(url),
        parsedUrl = Parser(url),
        userInfo = GetUser(url),
        powerfulToken = userInfo[Token],

        // exchange powerful token for weak token using GraphQL
        // this replaces the desktop service token exchange
        tokenExchangeResult = ExchangeToken(
            powerfulToken,
            {"profile:read", "streams:read", "users:read"},
            parsedUrl[projectId],
            parsedUrl[baseUrl]
        ),

        // throw error if token exchange failed - do NOT use powerful token as fallback
        tokenToUse = if tokenExchangeResult[Success] then
            tokenExchangeResult[Token]
        else
            error [
                Reason = "TokenExchangeFailed",
                Message.Format = "Failed to exchange token for limited scope token: #{0}",
                Message.Parameters = {tokenExchangeResult[ErrorMessage]},
                Detail = [
                    ErrorMessage = tokenExchangeResult[ErrorMessage],
                    ProjectId = parsedUrl[projectId],
                    ServerUrl = parsedUrl[baseUrl]
                ]
            ],

        // downloads data directly from server
        DirectDownload = (token as text) =>
            let
                objectUrl = Text.Combine({
                    parsedUrl[baseUrl],
                    "/objects/",
                    parsedUrl[projectId],
                    "/",
                    modelInfo[rootObjectId]
                }),

                Response = Web.Contents(
                    objectUrl,
                    [
                        Headers = [
                            #"Authorization" = "Bearer " & token,
                            #"Accept" = "application/json"
                        ],
                        ManualStatusHandling = {400, 401, 403, 404, 500, 502, 503, 504}
                    ]
                ),

                StatusCode = Value.Metadata(Response)[Response.Status],

                JsonResponse = if StatusCode >= 200 and StatusCode < 300 then
                    Json.Document(Response)
                else
                    error [
                        Reason = "DirectDownloadFailed",
                        Message.Format = "Failed to download model data from Speckle server (Status: #{0})",
                        Message.Parameters = {Text.From(StatusCode)},
                        Detail = [
                            StatusCode = StatusCode,
                            ObjectUrl = objectUrl,
                            ProjectId = parsedUrl[projectId],
                            RootObjectId = modelInfo[rootObjectId]
                        ]
                    ]
            in
                JsonResponse,

        // download data using the token (weak if exchange succeeded, powerful otherwise)
        FinalResult = DirectDownload(tokenToUse)

    in
        FinalResult
